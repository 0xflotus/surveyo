type Form {
    id: ID!
    title: String!
    description: String
    questions: [Question!]
}

interface Question {
    id: ID!
    question: String!
    required: Bool!
    # sensitive is true for personal data. We may want to restrict read access to this. May be set it non-nullable as well
    sensitive: [Bool]
} 

type MCQ implements Question {
    options: [String!]
}

type CheckBoxQuestion implements Question {
    options: [String!]
}

type TextQuestion implements Question {

}

type FormResponse {
    id: ID!
    responses: [QuestionReponse]
}

interface QuestionReponse {
    question: Question! 
}

type MCQResponse implements QuestionReponse {
    selection: Int!
}

type CheckBoxeResponse implements QuestionReponse {
    selections: [Int!]
}

type TextResponse implements QuestionReponse {
    text: String!
}

# alternative way to model responses 
# Modeling form response schema.
# Method 1:
# Different form response type for each form type
# it will have name like FormResponse_<Form-id> . It will have fields like response_<question-id> <ResponseType> etc.
# sensitive data goes into type Sensitive_<Form-id> inside form response
# This will be generated from code in the app when the user is creating the form.
# tricky part: Handling an edit to Form
# enum QuestionType {
#     MultipleChoice
#     CheckBoxes
#     DropDown
#     ShortAnswer
#     Paragraph
# }
